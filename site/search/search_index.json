{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project: Daphny Course name: Logic in Computer Science Team members S Dharshana 2023B5A71208H Bhavika Baburaj 2023B5A71210H Vedika Nirmal Kumar Singh 2023B4A71359H Sri Pujitha Konjeti 2023B1A71384H Project Layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage and Task 5. AbsoluteValue_Doc.md #Task 1 FindFirstNegative_Doc.md #Task 2 Factorial_Doc.md #Task 3 Tribonacci_Doc.md #Task 4 About the Project Overview This project was developed as part of Assignment 2 for the course CS F214: Logic in CS. The main goal of this assignment is to explore Formal Software Verification using the Dafny programming language. Unlike regular programming, where one writes tests for code to be run on certain inputs, in this project, one will write mathematical proofs embedded directly into the code. We define strict specifications so that the software is guaranteed to behave correctly for all possible inputs. Core Concepts Explored During the course of this project, we implemented several algorithms and proved them correct using the following Dafny constructs: Preconditions (requires): constraints that must be true prior to calling a method (e.g. array length is non-negative). Postconditions (ensures): Conditions that are guaranteed about the system state once a method has completed execution. Loop Invariants (invariant): Logical properties that hold before and after every iteration of a loop; used in the proof of Partial Correctness . Loop Variants (decreases): A measure that strictly decreases with every iteration to prove Termination (Total Correctness). Project Tasks The problems in this project involve four different algorithmic tasks, from simple arithmetic to complex sequence generation: Task 1: Absolute Value Goal: Implement a method to compute the absolute value of an integer. Focus: Basic method syntax and postconditions. Verification: Proved that the output is always non-negative and matches the mathematical definition \\(|x|\\) . Task 2: Find First Negative Goal: Perform a linear search to find the index of the first negative number in an array. Focus: Array manipulation and search logic. Verification: Proved that the method correctly identifies the first occurrence (ensuring no negative numbers exist before the index found) and handles cases where no negative numbers exist. Task 3: Factorial Goal: Use iteration to implement the computation of \\(n\\!\\) . Focus: Linking iterative implementations to recursive mathematical specifications. Verification: Used a recursive ghost function FactorialFunction to prove that the iterative accumulation correctly computes the mathematical factorial. Task 4: Tribonacci Sequence Goal: Use an iterative approach to find the \\(n\\) -th term of the Tribonacci sequence T_n = T_(n-1) + T_(n-2) + T_(n-3) Focus: Complex loop invariants using a \"sliding window\" approach. Verification: Maintained invariants for three variables simultaneously to prove the iterative step matches the recursive definition without the performance cost of recursion. Tools Used Language: Dafny (Microsoft Research) IDE: Visual Studio Code with Dafny Extension Verification Engine: Boogie / Z3 Theorem Prover","title":"Home"},{"location":"#project-daphny","text":"Course name: Logic in Computer Science","title":"Project: Daphny"},{"location":"#team-members","text":"S Dharshana 2023B5A71208H Bhavika Baburaj 2023B5A71210H Vedika Nirmal Kumar Singh 2023B4A71359H Sri Pujitha Konjeti 2023B1A71384H","title":"Team members"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage and Task 5. AbsoluteValue_Doc.md #Task 1 FindFirstNegative_Doc.md #Task 2 Factorial_Doc.md #Task 3 Tribonacci_Doc.md #Task 4","title":"Project Layout"},{"location":"#about-the-project","text":"","title":"About the Project"},{"location":"#overview","text":"This project was developed as part of Assignment 2 for the course CS F214: Logic in CS. The main goal of this assignment is to explore Formal Software Verification using the Dafny programming language. Unlike regular programming, where one writes tests for code to be run on certain inputs, in this project, one will write mathematical proofs embedded directly into the code. We define strict specifications so that the software is guaranteed to behave correctly for all possible inputs.","title":"Overview"},{"location":"#core-concepts-explored","text":"During the course of this project, we implemented several algorithms and proved them correct using the following Dafny constructs: Preconditions (requires): constraints that must be true prior to calling a method (e.g. array length is non-negative). Postconditions (ensures): Conditions that are guaranteed about the system state once a method has completed execution. Loop Invariants (invariant): Logical properties that hold before and after every iteration of a loop; used in the proof of Partial Correctness . Loop Variants (decreases): A measure that strictly decreases with every iteration to prove Termination (Total Correctness).","title":"Core Concepts Explored"},{"location":"#project-tasks","text":"The problems in this project involve four different algorithmic tasks, from simple arithmetic to complex sequence generation:","title":"Project Tasks"},{"location":"#task-1-absolute-value","text":"Goal: Implement a method to compute the absolute value of an integer. Focus: Basic method syntax and postconditions. Verification: Proved that the output is always non-negative and matches the mathematical definition \\(|x|\\) .","title":"Task 1: Absolute Value"},{"location":"#task-2-find-first-negative","text":"Goal: Perform a linear search to find the index of the first negative number in an array. Focus: Array manipulation and search logic. Verification: Proved that the method correctly identifies the first occurrence (ensuring no negative numbers exist before the index found) and handles cases where no negative numbers exist.","title":"Task 2: Find First Negative"},{"location":"#task-3-factorial","text":"Goal: Use iteration to implement the computation of \\(n\\!\\) . Focus: Linking iterative implementations to recursive mathematical specifications. Verification: Used a recursive ghost function FactorialFunction to prove that the iterative accumulation correctly computes the mathematical factorial.","title":"Task 3: Factorial"},{"location":"#task-4-tribonacci-sequence","text":"Goal: Use an iterative approach to find the \\(n\\) -th term of the Tribonacci sequence T_n = T_(n-1) + T_(n-2) + T_(n-3) Focus: Complex loop invariants using a \"sliding window\" approach. Verification: Maintained invariants for three variables simultaneously to prove the iterative step matches the recursive definition without the performance cost of recursion.","title":"Task 4: Tribonacci Sequence"},{"location":"#tools-used","text":"Language: Dafny (Microsoft Research) IDE: Visual Studio Code with Dafny Extension Verification Engine: Boogie / Z3 Theorem Prover","title":"Tools Used"},{"location":"AbsoluteValue_Doc/","text":"Method: Abs The Abs method calculates the absolute value of a given integer x. It ensures that the result is the non-negative magnitude of the input, adhering to the standard mathematical definition of absolute value: \\(|x|\\) . Preconditions There are no specific preconditions for this method other than the type constraint. Input Type: The input x must be an integer (int). It can be positive, negative, or zero. Postconditions The method guarantees the following properties upon completion: Non-Negative Result: The returned value x' is always greater than or equal to zero (x' >= 0) . Mathematical Correctness: The returned value satisfies the mathematical definition of absolute value: x' is equal to x (if x was positive or zero). OR x' is equal to -x (if x was negative). Loop Invariant This method does not contain any loops; it utilizes a simple conditional branching structure (if-else). Therefore, no loop invariants are required for verification. Logic Flow: If x >= 0 , the method returns x. If x < 0 , the method returns the negation -x (which results in a positive integer).","title":"Absolute Value"},{"location":"AbsoluteValue_Doc/#method-abs","text":"The Abs method calculates the absolute value of a given integer x. It ensures that the result is the non-negative magnitude of the input, adhering to the standard mathematical definition of absolute value: \\(|x|\\) .","title":"Method: Abs"},{"location":"AbsoluteValue_Doc/#preconditions","text":"There are no specific preconditions for this method other than the type constraint. Input Type: The input x must be an integer (int). It can be positive, negative, or zero.","title":"Preconditions"},{"location":"AbsoluteValue_Doc/#postconditions","text":"The method guarantees the following properties upon completion: Non-Negative Result: The returned value x' is always greater than or equal to zero (x' >= 0) . Mathematical Correctness: The returned value satisfies the mathematical definition of absolute value: x' is equal to x (if x was positive or zero). OR x' is equal to -x (if x was negative).","title":"Postconditions"},{"location":"AbsoluteValue_Doc/#loop-invariant","text":"This method does not contain any loops; it utilizes a simple conditional branching structure (if-else). Therefore, no loop invariants are required for verification. Logic Flow: If x >= 0 , the method returns x. If x < 0 , the method returns the negation -x (which results in a positive integer).","title":"Loop Invariant"},{"location":"Factorial_Doc/","text":"Method: Factorial The Factorial method iteratively computes the factorial of a non-negative integer n. The correctness of this implementation is verified against a purely mathematical recursive specification (FactorialFunction). The method avoids recursion in its implementation, utilizing a while loop to accumulate the product, which is often more memory-efficient for large inputs in compiled languages. Preconditions Natural Number Input: The input n is constrained to the type nat, meaning it must be a non-negative integer (n >= 0) . This is enforced by the type system and the method signature. Postconditions Verification against Specification: The returned value f must be exactly equal to the result of the recursive specification FactorialFunction(n) . This links the iterative code directly to the mathematical truth of factorials. Loop Invariant The loop invariants link the iterative state (variables i and result) to the mathematical definition as the loop progresses. Range Validity: The counter i remains within the bounds 0 <= i <= n throughout the execution. Accumulation Integrity: At the start of every iteration, the variable result holds the correct factorial value for the current counter i. invariant result == FactorialFunction(i) Initialization: When i=0, result is 1 since (0 != 1) . Maintenance: As i increments, result is updated to result * i, maintaining the invariant that result equals \\(i\\!\\) . Termination: When the loop finishes, i == n . Because the invariant holds, result must equal FactorialFunction(n) .","title":"Factorial"},{"location":"Factorial_Doc/#method-factorial","text":"The Factorial method iteratively computes the factorial of a non-negative integer n. The correctness of this implementation is verified against a purely mathematical recursive specification (FactorialFunction). The method avoids recursion in its implementation, utilizing a while loop to accumulate the product, which is often more memory-efficient for large inputs in compiled languages.","title":"Method: Factorial"},{"location":"Factorial_Doc/#preconditions","text":"Natural Number Input: The input n is constrained to the type nat, meaning it must be a non-negative integer (n >= 0) . This is enforced by the type system and the method signature.","title":"Preconditions"},{"location":"Factorial_Doc/#postconditions","text":"Verification against Specification: The returned value f must be exactly equal to the result of the recursive specification FactorialFunction(n) . This links the iterative code directly to the mathematical truth of factorials.","title":"Postconditions"},{"location":"Factorial_Doc/#loop-invariant","text":"The loop invariants link the iterative state (variables i and result) to the mathematical definition as the loop progresses. Range Validity: The counter i remains within the bounds 0 <= i <= n throughout the execution. Accumulation Integrity: At the start of every iteration, the variable result holds the correct factorial value for the current counter i. invariant result == FactorialFunction(i) Initialization: When i=0, result is 1 since (0 != 1) . Maintenance: As i increments, result is updated to result * i, maintaining the invariant that result equals \\(i\\!\\) . Termination: When the loop finishes, i == n . Because the invariant holds, result must equal FactorialFunction(n) .","title":"Loop Invariant"},{"location":"FindFirstNegative_Doc/","text":"Method: FindFirstNegative The FindFirstNegative method is a verified linear search algorithm that iterates through an integer array to find the index of the first negative value. If no negative numbers are found, the method correctly returns the length of the array to indicate the \"not found\" status. The implementation is verified for correctness, ensuring that it not only finds a negative number if one exists but specifically finds the first one, and correctly reports if none exist. Preconditions Preconditions define the constraints that must be met before the method is called. Array Validity: The input array a must have a non-negative length (a.Length >= 0) . This is a standard requirement for array processing, though Dafny naturally enforces non-negative lengths for array types. Postconditions The postconditions serve as a contract, guaranteeing the state of the result (index) after the method executes. Result Bounds: The returned index will always be in the range [0, a.Length] . Valid Detection: If index is strictly less than a.Length, the value at a[index] is guaranteed to be negative (a[index] < 0) . First Occurrence Guarantee: If a negative value is found at index, the method ensures that no negative values exist at any index k before it (0 <= k < index) . This proves it is the first negative number. Not Found Integrity: If the method returns a.Length, it guarantees that the entire array contains no negative numbers (i.e., forall k :: 0 <= k < a.Length ==> a[k] >= 0) . Loop Invariant The loop invariants explain \"why it works\" to the verifier, acting as the inductive proof of correctness during the iteration. Bounds Logic: The loop counter i is strictly maintained within the valid range 0 <= i <= a.Length . Partial Correctness (The \"Crucial\" Invariant): At the start of every iteration i, the algorithm has already verified that all elements checked so far (indices 0 to i-1) are non-negative. invariant forall k :: 0 <= k < i ==> a[k] >= 0 This ensures that if the loop eventually finds a negative number at i, it is genuinely the first one because strictly everything before i was non-negative. Conversely, if the loop reaches the end (i == a.Length) , this invariant implies the entire array is non-negative. Recorded initial failures In the first version of the code, I encountered a verification error when I set requires a != null as one of the preconditions. The error variable 'a' to have the value 'null' happened because in modern Dafny, arrays are \"non-null\" by default. Since I explicitly asked the verifier to check requires a != null , which is now redundant and causes an error. It has started working from the 2nd version.","title":"Find First Negative"},{"location":"FindFirstNegative_Doc/#method-findfirstnegative","text":"The FindFirstNegative method is a verified linear search algorithm that iterates through an integer array to find the index of the first negative value. If no negative numbers are found, the method correctly returns the length of the array to indicate the \"not found\" status. The implementation is verified for correctness, ensuring that it not only finds a negative number if one exists but specifically finds the first one, and correctly reports if none exist.","title":"Method: FindFirstNegative"},{"location":"FindFirstNegative_Doc/#preconditions","text":"Preconditions define the constraints that must be met before the method is called. Array Validity: The input array a must have a non-negative length (a.Length >= 0) . This is a standard requirement for array processing, though Dafny naturally enforces non-negative lengths for array types.","title":"Preconditions"},{"location":"FindFirstNegative_Doc/#postconditions","text":"The postconditions serve as a contract, guaranteeing the state of the result (index) after the method executes. Result Bounds: The returned index will always be in the range [0, a.Length] . Valid Detection: If index is strictly less than a.Length, the value at a[index] is guaranteed to be negative (a[index] < 0) . First Occurrence Guarantee: If a negative value is found at index, the method ensures that no negative values exist at any index k before it (0 <= k < index) . This proves it is the first negative number. Not Found Integrity: If the method returns a.Length, it guarantees that the entire array contains no negative numbers (i.e., forall k :: 0 <= k < a.Length ==> a[k] >= 0) .","title":"Postconditions"},{"location":"FindFirstNegative_Doc/#loop-invariant","text":"The loop invariants explain \"why it works\" to the verifier, acting as the inductive proof of correctness during the iteration. Bounds Logic: The loop counter i is strictly maintained within the valid range 0 <= i <= a.Length . Partial Correctness (The \"Crucial\" Invariant): At the start of every iteration i, the algorithm has already verified that all elements checked so far (indices 0 to i-1) are non-negative. invariant forall k :: 0 <= k < i ==> a[k] >= 0 This ensures that if the loop eventually finds a negative number at i, it is genuinely the first one because strictly everything before i was non-negative. Conversely, if the loop reaches the end (i == a.Length) , this invariant implies the entire array is non-negative.","title":"Loop Invariant"},{"location":"FindFirstNegative_Doc/#recorded-initial-failures","text":"In the first version of the code, I encountered a verification error when I set requires a != null as one of the preconditions. The error variable 'a' to have the value 'null' happened because in modern Dafny, arrays are \"non-null\" by default. Since I explicitly asked the verifier to check requires a != null , which is now redundant and causes an error. It has started working from the 2nd version.","title":"Recorded initial failures"},{"location":"Tribonacci_Doc/","text":"Method: ComputeTrib The ComputeTrib method calculates the \\(n\\) -th Tribonacci number iteratively. The Tribonacci sequence is similar to the Fibonacci sequence, but each term is the sum of the three previous terms rather than two. The sequence starts with 0, 1, 1. This method uses a \"sliding window\" approach to calculate the value in \\(O(n)\\) time complexity and \\(O(1)\\) space complexity, avoiding the exponential cost of naive recursion. Preconditions Natural Number Input: The input n must be a non-negative integer (nat). This implies n >= 0 . Postconditions Correctness: The returned value res is guaranteed to be equal to Trib(n) , where Trib is the mathematical function defining the sequence recursively. Loop Invariant The loop invariants are critical here to prove that the three variables (a, b, c) correctly represent the \"window\" of the Tribonacci sequence at any step i. Counter Range: The loop counter i is strictly within the range 1 <= i <= n . Window Consistency: The variables a, b, and c always map to specific positions in the sequence relative to i: a represents \\(T(i-1)\\) b represents \\(T(i)\\) (This is the value tracked for the final result) c represents \\(T(i+1)\\) By maintaining this window, the algorithm ensures that when the loop terminates (at i == n) , the variable b holds the value of \\(T(n)\\) .","title":"Tribonacci"},{"location":"Tribonacci_Doc/#method-computetrib","text":"The ComputeTrib method calculates the \\(n\\) -th Tribonacci number iteratively. The Tribonacci sequence is similar to the Fibonacci sequence, but each term is the sum of the three previous terms rather than two. The sequence starts with 0, 1, 1. This method uses a \"sliding window\" approach to calculate the value in \\(O(n)\\) time complexity and \\(O(1)\\) space complexity, avoiding the exponential cost of naive recursion.","title":"Method: ComputeTrib"},{"location":"Tribonacci_Doc/#preconditions","text":"Natural Number Input: The input n must be a non-negative integer (nat). This implies n >= 0 .","title":"Preconditions"},{"location":"Tribonacci_Doc/#postconditions","text":"Correctness: The returned value res is guaranteed to be equal to Trib(n) , where Trib is the mathematical function defining the sequence recursively.","title":"Postconditions"},{"location":"Tribonacci_Doc/#loop-invariant","text":"The loop invariants are critical here to prove that the three variables (a, b, c) correctly represent the \"window\" of the Tribonacci sequence at any step i. Counter Range: The loop counter i is strictly within the range 1 <= i <= n . Window Consistency: The variables a, b, and c always map to specific positions in the sequence relative to i: a represents \\(T(i-1)\\) b represents \\(T(i)\\) (This is the value tracked for the final result) c represents \\(T(i+1)\\) By maintaining this window, the algorithm ensures that when the loop terminates (at i == n) , the variable b holds the value of \\(T(n)\\) .","title":"Loop Invariant"}]}