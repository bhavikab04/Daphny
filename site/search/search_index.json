{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project: Daphny Course name: Logic in Computer Science Team members S Dharshana 2023B5A71208H Bhavika Baburaj 2023B5A71210H Vedika Nirmal Kumar Singh 2023B4A71359H Sri Pujitha Konjeti 2023B1A71384H Project Layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage and Task 5. AbsoluteValue_Doc.md #Task 1 FindFirstNegative_Doc.md #Task 2 Factorial_Doc.md #Task 3 Tribonacci_Doc.md #Task 4 About the Project Overview This project was developed as part of Assignment 2 for the course CS F214: Logic in CS. The main goal of this assignment is to explore Formal Software Verification using the Dafny programming language. Unlike regular programming, where one writes tests for code to be run on certain inputs, in this project, one will write mathematical proofs embedded directly into the code. We define strict specifications so that the software is guaranteed to behave correctly for all possible inputs. Core Concepts Explored During the course of this project, we implemented several algorithms and proved them correct using the following Dafny constructs: Preconditions (requires): constraints that must be true prior to calling a method (e.g. array length is non-negative). Postconditions (ensures): Conditions that are guaranteed about the system state once a method has completed execution. Loop Invariants (invariant): Logical properties that hold before and after every iteration of a loop; used in the proof of Partial Correctness . Loop Variants (decreases): A measure that strictly decreases with every iteration to prove Termination (Total Correctness). Project Tasks The problems in this project involve four different algorithmic tasks, from simple arithmetic to complex sequence generation: Task 1: Absolute Value Goal: Implement a method to compute the absolute value of an integer. Focus: Basic method syntax and postconditions. Verification: Proved that the output is always non-negative and matches the mathematical definition \\(|x|\\) . Task 2: Find First Negative Goal: Perform a linear search to find the index of the first negative number in an array. Focus: Array manipulation and search logic. Verification: Proved that the method correctly identifies the first occurrence (ensuring no negative numbers exist before the index found) and handles cases where no negative numbers exist. Task 3: Factorial Goal: Use iteration to implement the computation of \\(n\\!\\) . Focus: Linking iterative implementations to recursive mathematical specifications. Verification: Used a recursive ghost function FactorialFunction to prove that the iterative accumulation correctly computes the mathematical factorial. Task 4: Tribonacci Sequence Goal: Use an iterative approach to find the \\(n\\) -th term of the Tribonacci sequence T_n = T_(n-1) + T_(n-2) + T_(n-3) Focus: Complex loop invariants using a \"sliding window\" approach. Verification: Maintained invariants for three variables simultaneously to prove the iterative step matches the recursive definition without the performance cost of recursion. Tools Used Language: Dafny (Microsoft Research) IDE: Visual Studio Code with Dafny Extension Verification Engine: Boogie / Z3 Theorem Prover","title":"Home"},{"location":"#project-daphny","text":"Course name: Logic in Computer Science","title":"Project: Daphny"},{"location":"#team-members","text":"S Dharshana 2023B5A71208H Bhavika Baburaj 2023B5A71210H Vedika Nirmal Kumar Singh 2023B4A71359H Sri Pujitha Konjeti 2023B1A71384H","title":"Team members"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage and Task 5. AbsoluteValue_Doc.md #Task 1 FindFirstNegative_Doc.md #Task 2 Factorial_Doc.md #Task 3 Tribonacci_Doc.md #Task 4","title":"Project Layout"},{"location":"#about-the-project","text":"","title":"About the Project"},{"location":"#overview","text":"This project was developed as part of Assignment 2 for the course CS F214: Logic in CS. The main goal of this assignment is to explore Formal Software Verification using the Dafny programming language. Unlike regular programming, where one writes tests for code to be run on certain inputs, in this project, one will write mathematical proofs embedded directly into the code. We define strict specifications so that the software is guaranteed to behave correctly for all possible inputs.","title":"Overview"},{"location":"#core-concepts-explored","text":"During the course of this project, we implemented several algorithms and proved them correct using the following Dafny constructs: Preconditions (requires): constraints that must be true prior to calling a method (e.g. array length is non-negative). Postconditions (ensures): Conditions that are guaranteed about the system state once a method has completed execution. Loop Invariants (invariant): Logical properties that hold before and after every iteration of a loop; used in the proof of Partial Correctness . Loop Variants (decreases): A measure that strictly decreases with every iteration to prove Termination (Total Correctness).","title":"Core Concepts Explored"},{"location":"#project-tasks","text":"The problems in this project involve four different algorithmic tasks, from simple arithmetic to complex sequence generation:","title":"Project Tasks"},{"location":"#task-1-absolute-value","text":"Goal: Implement a method to compute the absolute value of an integer. Focus: Basic method syntax and postconditions. Verification: Proved that the output is always non-negative and matches the mathematical definition \\(|x|\\) .","title":"Task 1: Absolute Value"},{"location":"#task-2-find-first-negative","text":"Goal: Perform a linear search to find the index of the first negative number in an array. Focus: Array manipulation and search logic. Verification: Proved that the method correctly identifies the first occurrence (ensuring no negative numbers exist before the index found) and handles cases where no negative numbers exist.","title":"Task 2: Find First Negative"},{"location":"#task-3-factorial","text":"Goal: Use iteration to implement the computation of \\(n\\!\\) . Focus: Linking iterative implementations to recursive mathematical specifications. Verification: Used a recursive ghost function FactorialFunction to prove that the iterative accumulation correctly computes the mathematical factorial.","title":"Task 3: Factorial"},{"location":"#task-4-tribonacci-sequence","text":"Goal: Use an iterative approach to find the \\(n\\) -th term of the Tribonacci sequence T_n = T_(n-1) + T_(n-2) + T_(n-3) Focus: Complex loop invariants using a \"sliding window\" approach. Verification: Maintained invariants for three variables simultaneously to prove the iterative step matches the recursive definition without the performance cost of recursion.","title":"Task 4: Tribonacci Sequence"},{"location":"#tools-used","text":"Language: Dafny (Microsoft Research) IDE: Visual Studio Code with Dafny Extension Verification Engine: Boogie / Z3 Theorem Prover","title":"Tools Used"},{"location":"AbsoluteValue_Doc/","text":"Method: Abs The Abs method calculates the absolute value of a given integer x. It ensures that the result is the non-negative magnitude of the input, adhering to the standard mathematical definition of absolute value: \\(|x|\\) . Preconditions There are no specific preconditions for this method other than the type constraint. Input Type: The input x must be an integer (int). It can be positive, negative, or zero. Postconditions The method guarantees the following properties upon completion: Non-Negative Result: The returned value x' is always greater than or equal to zero (x' >= 0) . Mathematical Correctness: The returned value satisfies the mathematical definition of absolute value: x' is equal to x (if x was positive or zero). OR x' is equal to -x (if x was negative). Loop Invariant This method does not contain any loops; it utilizes a simple conditional branching structure (if-else). Therefore, no loop invariants are required for verification. Logic Flow: If x >= 0 , the method returns x. If x < 0 , the method returns the negation -x (which results in a positive integer). Cases where it fails Case A: The \"Too Strict\" Precondition (Verification Failure at Call Site) Hypothesis: What if we force the user to only input positive numbers? dafny method AbsStrict(x: int) returns (x': int) requires x >= 0 // <--- BAD PRECONDITION for a general Abs function ensures x' == x { x' := x; } method Main() { var res := AbsStrict(-5); // ERROR: Verification Failed Here! } Result: VERIFICATION FAILED . Reason : The method AbsStrict is verified correctly internally (it does what it says it will do), but the Main method fails verification because we violated the requires x >= 0 rule by passing -5. Case B: The \"Wrong\" Postcondition (Verification Failure in Logic) Hypothesis : What if we promise that the output equals the input, even for negative numbers? method AbsWrong(x: int) returns (x': int) ensures x' == x // <--- WRONG POSTCONDITION { if x < 0 { x' := -x; // Logic returns positive } else { x' := x; } } Result: VERIFICATION FAILED. Reason : Dafny analyzes the if x < 0 branch and finds a contradiction: It sees x = -5 . The logic sets x' = 5 (because -(-5) = 5). The postcondition expects x' == x (i.e., it expects 5 == -5). Since 5 == -5 is false, Dafny reports that the code does not satisfy the postcondition.","title":"Absolute Value"},{"location":"AbsoluteValue_Doc/#method-abs","text":"The Abs method calculates the absolute value of a given integer x. It ensures that the result is the non-negative magnitude of the input, adhering to the standard mathematical definition of absolute value: \\(|x|\\) .","title":"Method: Abs"},{"location":"AbsoluteValue_Doc/#preconditions","text":"There are no specific preconditions for this method other than the type constraint. Input Type: The input x must be an integer (int). It can be positive, negative, or zero.","title":"Preconditions"},{"location":"AbsoluteValue_Doc/#postconditions","text":"The method guarantees the following properties upon completion: Non-Negative Result: The returned value x' is always greater than or equal to zero (x' >= 0) . Mathematical Correctness: The returned value satisfies the mathematical definition of absolute value: x' is equal to x (if x was positive or zero). OR x' is equal to -x (if x was negative).","title":"Postconditions"},{"location":"AbsoluteValue_Doc/#loop-invariant","text":"This method does not contain any loops; it utilizes a simple conditional branching structure (if-else). Therefore, no loop invariants are required for verification. Logic Flow: If x >= 0 , the method returns x. If x < 0 , the method returns the negation -x (which results in a positive integer).","title":"Loop Invariant"},{"location":"AbsoluteValue_Doc/#cases-where-it-fails","text":"","title":"Cases where it fails"},{"location":"AbsoluteValue_Doc/#case-a-the-too-strict-precondition-verification-failure-at-call-site","text":"Hypothesis: What if we force the user to only input positive numbers? dafny method AbsStrict(x: int) returns (x': int) requires x >= 0 // <--- BAD PRECONDITION for a general Abs function ensures x' == x { x' := x; } method Main() { var res := AbsStrict(-5); // ERROR: Verification Failed Here! } Result: VERIFICATION FAILED . Reason : The method AbsStrict is verified correctly internally (it does what it says it will do), but the Main method fails verification because we violated the requires x >= 0 rule by passing -5.","title":"Case A: The \"Too Strict\" Precondition (Verification Failure at Call Site)"},{"location":"AbsoluteValue_Doc/#case-b-the-wrong-postcondition-verification-failure-in-logic","text":"Hypothesis : What if we promise that the output equals the input, even for negative numbers? method AbsWrong(x: int) returns (x': int) ensures x' == x // <--- WRONG POSTCONDITION { if x < 0 { x' := -x; // Logic returns positive } else { x' := x; } } Result: VERIFICATION FAILED. Reason : Dafny analyzes the if x < 0 branch and finds a contradiction: It sees x = -5 . The logic sets x' = 5 (because -(-5) = 5). The postcondition expects x' == x (i.e., it expects 5 == -5). Since 5 == -5 is false, Dafny reports that the code does not satisfy the postcondition.","title":"Case B: The \"Wrong\" Postcondition (Verification Failure in Logic)"},{"location":"Factorial_Doc/","text":"Method: Factorial The Factorial method iteratively computes the factorial of a non-negative integer n. The correctness of this implementation is verified against a purely mathematical recursive specification (FactorialFunction). The method avoids recursion in its implementation, utilizing a while loop to accumulate the product, which is often more memory-efficient for large inputs in compiled languages. Preconditions Natural Number Input: The input n is constrained to the type nat, meaning it must be a non-negative integer (n >= 0) . This is enforced by the type system and the method signature. Postconditions Verification against Specification: The returned value f must be exactly equal to the result of the recursive specification FactorialFunction(n) . This links the iterative code directly to the mathematical truth of factorials. Loop Invariant The loop invariants link the iterative state (variables i and result) to the mathematical definition as the loop progresses. Range Validity: The counter i remains within the bounds 0 <= i <= n throughout the execution. Accumulation Integrity: At the start of every iteration, the variable result holds the correct factorial value for the current counter i. invariant result == FactorialFunction(i) Initialization: When i=0, result is 1 since (0 != 1) . Maintenance: As i increments, result is updated to result * i, maintaining the invariant that result equals \\(i\\!\\) . Termination: When the loop finishes, i == n . Because the invariant holds, result must equal FactorialFunction(n) . Here we have documented the testing of the iterative Factorial method using formal verification components in Dafny. The goal is to demonstrate the purpose of preconditions ( requires ), postconditions ( ensures ), loop invariants ( invariant ), and loop variants ( decreases ) by observing when the verification process succeeds or fails against the logic in the file DafnyFactorialVerification.dfy . Test 1: Successful Verification (Factorial_Success) This case represents the correctly verified code. The verifier confirms that the code meets its specification. Component Code Status Verification Outcome Precondition ( requires ) true Pass Input n is guaranteed to be a natural number ( nat ). Postcondition ( ensures ) f == FactorialFunction(n) Pass The verifier confirms that upon termination, the final result f is mathematically equal to \\(n!\\) . Loop Invariant ( invariant ) result == FactorialFunction(i) Pass The invariant is successfully proven to be true at initialization, maintained in the loop body, and guarantees the postcondition at termination. Loop Variant ( decreases ) n - i Pass The value strictly decreases from n to 0 with each step, guaranteeing the loop terminates. Test 2: Verification Failure Cases The following test methods contain intentional errors in either the code logic or the formal specification, causing the Dafny verifier to fail and highlight the exact point of contradiction. Case A: Failure Due to Incorrect Postcondition (Factorial_Fail_Postcondition) Component Intentional Change Failure Location Reason Postcondition ( ensures ) ensures f == FactorialFunction(n) + 1 The ensures clause The method computes f = n! , but the specification demands f = n! + 1 . The proof that \\(n! = n! + 1\\) fails for all \\(n \\ge 0\\) . Dafny Error A postcondition will not hold on this return path. Case B: Failure Due to Incorrect Loop Invariant (Factorial_Fail_Invariant_Init) Component Intentional Change Failure Location Reason Code Initialization var result := 0; (Should be 1 ) The invariant result == FactorialFunction(i) At the start of the loop, i=0 . The invariant requires \\(result = 0! = 1\\) . The code provides \\(result = 0\\) , violating the invariant before the loop begins. Dafny Error Loop invariant may not hold at the beginning of the loop. Case C: Failure Due to Incorrect Loop Invariant (Factorial_Fail_Invariant_Maintenance) Component Intentional Change Failure Location Reason Loop Body Skipped result := result * i; The invariant result == FactorialFunction(i) The invariant holds for the old i . When i increments, the stored result is only \\(i!\\) (because multiplication was skipped), which is not equal to \\((i+1)!\\) , violating the invariant for the new value of i . Dafny Error Loop invariant may not be maintained by the loop body. Case D: Failure Due to Incorrect Loop Variant (Factorial_Fail_Variant) Component Intentional Change Failure Location Reason Loop Variant ( decreases ) decreases n The decreases n clause The variant expression must strictly decrease with every iteration. Since n is a constant and remains unchanged, it fails the strict decrease requirement, indicating a potential non-terminating loop. Dafny Error The loop variant may not decrease.","title":"Factorial"},{"location":"Factorial_Doc/#method-factorial","text":"The Factorial method iteratively computes the factorial of a non-negative integer n. The correctness of this implementation is verified against a purely mathematical recursive specification (FactorialFunction). The method avoids recursion in its implementation, utilizing a while loop to accumulate the product, which is often more memory-efficient for large inputs in compiled languages.","title":"Method: Factorial"},{"location":"Factorial_Doc/#preconditions","text":"Natural Number Input: The input n is constrained to the type nat, meaning it must be a non-negative integer (n >= 0) . This is enforced by the type system and the method signature.","title":"Preconditions"},{"location":"Factorial_Doc/#postconditions","text":"Verification against Specification: The returned value f must be exactly equal to the result of the recursive specification FactorialFunction(n) . This links the iterative code directly to the mathematical truth of factorials.","title":"Postconditions"},{"location":"Factorial_Doc/#loop-invariant","text":"The loop invariants link the iterative state (variables i and result) to the mathematical definition as the loop progresses. Range Validity: The counter i remains within the bounds 0 <= i <= n throughout the execution. Accumulation Integrity: At the start of every iteration, the variable result holds the correct factorial value for the current counter i. invariant result == FactorialFunction(i) Initialization: When i=0, result is 1 since (0 != 1) . Maintenance: As i increments, result is updated to result * i, maintaining the invariant that result equals \\(i\\!\\) . Termination: When the loop finishes, i == n . Because the invariant holds, result must equal FactorialFunction(n) . Here we have documented the testing of the iterative Factorial method using formal verification components in Dafny. The goal is to demonstrate the purpose of preconditions ( requires ), postconditions ( ensures ), loop invariants ( invariant ), and loop variants ( decreases ) by observing when the verification process succeeds or fails against the logic in the file DafnyFactorialVerification.dfy .","title":"Loop Invariant"},{"location":"Factorial_Doc/#test-1-successful-verification-factorial_success","text":"This case represents the correctly verified code. The verifier confirms that the code meets its specification. Component Code Status Verification Outcome Precondition ( requires ) true Pass Input n is guaranteed to be a natural number ( nat ). Postcondition ( ensures ) f == FactorialFunction(n) Pass The verifier confirms that upon termination, the final result f is mathematically equal to \\(n!\\) . Loop Invariant ( invariant ) result == FactorialFunction(i) Pass The invariant is successfully proven to be true at initialization, maintained in the loop body, and guarantees the postcondition at termination. Loop Variant ( decreases ) n - i Pass The value strictly decreases from n to 0 with each step, guaranteeing the loop terminates.","title":"Test 1: Successful Verification (Factorial_Success)"},{"location":"Factorial_Doc/#test-2-verification-failure-cases","text":"The following test methods contain intentional errors in either the code logic or the formal specification, causing the Dafny verifier to fail and highlight the exact point of contradiction.","title":"Test 2: Verification Failure Cases"},{"location":"Factorial_Doc/#case-a-failure-due-to-incorrect-postcondition-factorial_fail_postcondition","text":"Component Intentional Change Failure Location Reason Postcondition ( ensures ) ensures f == FactorialFunction(n) + 1 The ensures clause The method computes f = n! , but the specification demands f = n! + 1 . The proof that \\(n! = n! + 1\\) fails for all \\(n \\ge 0\\) . Dafny Error A postcondition will not hold on this return path.","title":"Case A: Failure Due to Incorrect Postcondition (Factorial_Fail_Postcondition)"},{"location":"Factorial_Doc/#case-b-failure-due-to-incorrect-loop-invariant-factorial_fail_invariant_init","text":"Component Intentional Change Failure Location Reason Code Initialization var result := 0; (Should be 1 ) The invariant result == FactorialFunction(i) At the start of the loop, i=0 . The invariant requires \\(result = 0! = 1\\) . The code provides \\(result = 0\\) , violating the invariant before the loop begins. Dafny Error Loop invariant may not hold at the beginning of the loop.","title":"Case B: Failure Due to Incorrect Loop Invariant (Factorial_Fail_Invariant_Init)"},{"location":"Factorial_Doc/#case-c-failure-due-to-incorrect-loop-invariant-factorial_fail_invariant_maintenance","text":"Component Intentional Change Failure Location Reason Loop Body Skipped result := result * i; The invariant result == FactorialFunction(i) The invariant holds for the old i . When i increments, the stored result is only \\(i!\\) (because multiplication was skipped), which is not equal to \\((i+1)!\\) , violating the invariant for the new value of i . Dafny Error Loop invariant may not be maintained by the loop body.","title":"Case C: Failure Due to Incorrect Loop Invariant (Factorial_Fail_Invariant_Maintenance)"},{"location":"Factorial_Doc/#case-d-failure-due-to-incorrect-loop-variant-factorial_fail_variant","text":"Component Intentional Change Failure Location Reason Loop Variant ( decreases ) decreases n The decreases n clause The variant expression must strictly decrease with every iteration. Since n is a constant and remains unchanged, it fails the strict decrease requirement, indicating a potential non-terminating loop. Dafny Error The loop variant may not decrease.","title":"Case D: Failure Due to Incorrect Loop Variant (Factorial_Fail_Variant)"},{"location":"FindFirstNegative_Doc/","text":"Method: FindFirstNegative The FindFirstNegative method is a verified linear search algorithm that iterates through an integer array to find the index of the first negative value. If no negative numbers are found, the method correctly returns the length of the array to indicate the \"not found\" status. The implementation is verified for correctness, ensuring that it not only finds a negative number if one exists but specifically finds the first one, and correctly reports if none exist. Preconditions Preconditions define the constraints that must be met before the method is called. Array Validity: The input array a must have a non-negative length (a.Length >= 0) . This is a standard requirement for array processing, though Dafny naturally enforces non-negative lengths for array types. Postconditions The postconditions serve as a contract, guaranteeing the state of the result (index) after the method executes. Result Bounds: The returned index will always be in the range [0, a.Length] . Valid Detection: If index is strictly less than a.Length, the value at a[index] is guaranteed to be negative (a[index] < 0) . First Occurrence Guarantee: If a negative value is found at index, the method ensures that no negative values exist at any index k before it (0 <= k < index) . This proves it is the first negative number. Not Found Integrity: If the method returns a.Length, it guarantees that the entire array contains no negative numbers (i.e., forall k :: 0 <= k < a.Length ==> a[k] >= 0) . Loop Invariant The loop invariants explain \"why it works\" to the verifier, acting as the inductive proof of correctness during the iteration. Bounds Logic: The loop counter i is strictly maintained within the valid range 0 <= i <= a.Length . Partial Correctness (The \"Crucial\" Invariant): At the start of every iteration i, the algorithm has already verified that all elements checked so far (indices 0 to i-1) are non-negative. invariant forall k :: 0 <= k < i ==> a[k] >= 0 This ensures that if the loop eventually finds a negative number at i, it is genuinely the first one because strictly everything before i was non-negative. Conversely, if the loop reaches the end (i == a.Length) , this invariant implies the entire array is non-negative. Recorded initial failures In the first version of the code, I encountered a verification error when I set requires a != null as one of the preconditions. The error variable 'a' to have the value 'null' happened because in modern Dafny, arrays are \"non-null\" by default. Since I explicitly asked the verifier to check requires a != null , which is now redundant and causes an error. It has started working from the 2nd version. Cases Where Verification Failed (Failing Proofs) If a specification element is incorrect or missing, Dafny's verifier will fail the proof. These failures are critical because they highlight logical gaps in the formal proof. Failure Case A: Missing Postcondition ( ensures ) This failure occurs when a required property of the output is omitted, violating the intended logic (finding the first negative number). Element Description/Change Dafny's Failure Point Rationale for Failure Missing Postcondition Omitted: ensures index < a.Length ==> forall k :: 0 <= k < index ==> a[k] >= 0 The verifier only proves the method found a negative number, not the first one. The lack of a constraint on \\(0 \\le k < index\\) allows the method to skip earlier negative numbers. For example, the verifier technically accepts index = 4 for the array [1, -1, 1, 1, -5] . Result Omit the postcondition that guarantees non-negativity before the result. The verifier cannot prove the final state is correct because the specification is incomplete . The verifier can only ensure the element at index is negative, not that it is the earliest one. Failure Case B: Weak Loop Invariant This is a structural proof failure. The loop invariant is the only mechanism that allows Dafny to carry proof knowledge from the beginning of the loop to its end. Element Description/Change Dafny's Failure Point Rationale for Failure Missing Loop Invariant Omitted: invariant forall k :: 0 <= k < i ==> a[k] >= 0 Assertion Failure on Exit: The verifier cannot prove the postcondition ensures index == a.Length ==> forall k :: 0 <= k < a.Length ==> a[k] >= 0 . Reason Omit the core logic that tracks the history of the loop. When the loop finishes, \\(i = a.Length\\) . Without this invariant, Dafny has no memory that the array elements checked up to \\(i-1\\) were ever proven non-negative. The proof collapses because the proof history inside the loop is lost.","title":"Find First Negative"},{"location":"FindFirstNegative_Doc/#method-findfirstnegative","text":"The FindFirstNegative method is a verified linear search algorithm that iterates through an integer array to find the index of the first negative value. If no negative numbers are found, the method correctly returns the length of the array to indicate the \"not found\" status. The implementation is verified for correctness, ensuring that it not only finds a negative number if one exists but specifically finds the first one, and correctly reports if none exist.","title":"Method: FindFirstNegative"},{"location":"FindFirstNegative_Doc/#preconditions","text":"Preconditions define the constraints that must be met before the method is called. Array Validity: The input array a must have a non-negative length (a.Length >= 0) . This is a standard requirement for array processing, though Dafny naturally enforces non-negative lengths for array types.","title":"Preconditions"},{"location":"FindFirstNegative_Doc/#postconditions","text":"The postconditions serve as a contract, guaranteeing the state of the result (index) after the method executes. Result Bounds: The returned index will always be in the range [0, a.Length] . Valid Detection: If index is strictly less than a.Length, the value at a[index] is guaranteed to be negative (a[index] < 0) . First Occurrence Guarantee: If a negative value is found at index, the method ensures that no negative values exist at any index k before it (0 <= k < index) . This proves it is the first negative number. Not Found Integrity: If the method returns a.Length, it guarantees that the entire array contains no negative numbers (i.e., forall k :: 0 <= k < a.Length ==> a[k] >= 0) .","title":"Postconditions"},{"location":"FindFirstNegative_Doc/#loop-invariant","text":"The loop invariants explain \"why it works\" to the verifier, acting as the inductive proof of correctness during the iteration. Bounds Logic: The loop counter i is strictly maintained within the valid range 0 <= i <= a.Length . Partial Correctness (The \"Crucial\" Invariant): At the start of every iteration i, the algorithm has already verified that all elements checked so far (indices 0 to i-1) are non-negative. invariant forall k :: 0 <= k < i ==> a[k] >= 0 This ensures that if the loop eventually finds a negative number at i, it is genuinely the first one because strictly everything before i was non-negative. Conversely, if the loop reaches the end (i == a.Length) , this invariant implies the entire array is non-negative.","title":"Loop Invariant"},{"location":"FindFirstNegative_Doc/#recorded-initial-failures","text":"In the first version of the code, I encountered a verification error when I set requires a != null as one of the preconditions. The error variable 'a' to have the value 'null' happened because in modern Dafny, arrays are \"non-null\" by default. Since I explicitly asked the verifier to check requires a != null , which is now redundant and causes an error. It has started working from the 2nd version.","title":"Recorded initial failures"},{"location":"FindFirstNegative_Doc/#cases-where-verification-failed-failing-proofs","text":"If a specification element is incorrect or missing, Dafny's verifier will fail the proof. These failures are critical because they highlight logical gaps in the formal proof.","title":"Cases Where Verification Failed (Failing Proofs)"},{"location":"FindFirstNegative_Doc/#failure-case-a-missing-postcondition-ensures","text":"This failure occurs when a required property of the output is omitted, violating the intended logic (finding the first negative number). Element Description/Change Dafny's Failure Point Rationale for Failure Missing Postcondition Omitted: ensures index < a.Length ==> forall k :: 0 <= k < index ==> a[k] >= 0 The verifier only proves the method found a negative number, not the first one. The lack of a constraint on \\(0 \\le k < index\\) allows the method to skip earlier negative numbers. For example, the verifier technically accepts index = 4 for the array [1, -1, 1, 1, -5] . Result Omit the postcondition that guarantees non-negativity before the result. The verifier cannot prove the final state is correct because the specification is incomplete . The verifier can only ensure the element at index is negative, not that it is the earliest one.","title":"Failure Case A: Missing Postcondition (ensures)"},{"location":"FindFirstNegative_Doc/#failure-case-b-weak-loop-invariant","text":"This is a structural proof failure. The loop invariant is the only mechanism that allows Dafny to carry proof knowledge from the beginning of the loop to its end. Element Description/Change Dafny's Failure Point Rationale for Failure Missing Loop Invariant Omitted: invariant forall k :: 0 <= k < i ==> a[k] >= 0 Assertion Failure on Exit: The verifier cannot prove the postcondition ensures index == a.Length ==> forall k :: 0 <= k < a.Length ==> a[k] >= 0 . Reason Omit the core logic that tracks the history of the loop. When the loop finishes, \\(i = a.Length\\) . Without this invariant, Dafny has no memory that the array elements checked up to \\(i-1\\) were ever proven non-negative. The proof collapses because the proof history inside the loop is lost.","title":"Failure Case B: Weak Loop Invariant"},{"location":"Tribonacci_Doc/","text":"Formal Verification Report: The ComputeTrib Method 1. Introduction The ComputeTrib method calculates the \\(n\\) -th Tribonacci number iteratively. The Tribonacci sequence is similar to the Fibonacci sequence, but each term is the sum of the three previous terms rather than two. The sequence is defined recursively as follows: \\[ T(n) = \\begin{cases} 0 & \\text{if } n = 0 \\\\ 1 & \\text{if } n = 1 \\\\ 1 & \\text{if } n = 2 \\\\ T(n-1) + T(n-2) + T(n-3) & \\text{if } n > 2 \\end{cases} \\] The sequence begins: \\(0, 1, 1, 2, 4, 7, 13, \\dots\\) This method utilizes a \"sliding window\" approach to calculate the value in \\(O(n)\\) time complexity and \\(O(1)\\) space complexity, avoiding the exponential cost of naive recursion. This report documents all correctness conditions used in the Dafny implementation, records verification failures encountered during experimentation, and explains the rationale behind those failures. 2. Formal Specification 2.1 Preconditions Final Correct Preconditions (Working Version) requires n >= 0 Although defining n as a natural number ( nat ) guarantees non-negativity, the explicit precondition clarifies the domain of the function. No other preconditions are required. Experimented Failing Preconditions Attempted Condition Result Reason for Failure (none) Verified Dafny inferred bounds from nat . However, this was less clear from a specification standpoint. requires n > 0 Failed When \\(n = 0\\) , the method returns 0, but the postcondition requires res == Trib(n) where Trib(0) is valid. Restricting n > 0 made the base-case correct but unnecessary, and Dafny rejected the invariant range \\(1 \\leq i \\leq n\\) when \\(n = 0\\) . 2.2 Postconditions Final Correct Postcondition ensures res == Trib(n) This connects the implementation to the mathematical specification, ensuring functional correctness. Experimented Failing Postconditions Attempted Condition Result Reason for Failure ensures res >= 0 Verified Too weak; does not guarantee functional correctness. ensures res == Trib(n) + 1 Failed Cannot be proven true; contradicts the intended behavior. ensures res == a (or b , or c ) Failed At return time, only b holds the correct Tribonacci value. Dafny cannot prove the disjunction. 3. Loop Mechanics The loop invariants are critical to prove that the three variables ( \\(a, b, c\\) ) correctly represent the \"window\" of the Tribonacci sequence at any step \\(i\\) . 3.1 Loop Invariants Final Working Invariants invariant 1 <= i <= n invariant a == Trib(i-1) invariant b == Trib(i) invariant c == Trib(i+1) Window Consistency The variables always map to specific positions in the sequence relative to \\(i\\) : \\(a\\) represents \\(T(i-1)\\) \\(b\\) represents \\(T(i)\\) (This is the value tracked for the final result) \\(c\\) represents \\(T(i+1)\\) By maintaining this window, the algorithm ensures that when the loop terminates (at \\(i == n\\) ), the variable \\(b\\) holds the value of \\(T(n)\\) . Experimented Failing Loop Invariants Invariant Attempt Result Why It Failed invariant a == Trib(i) Failed Misaligned indexing. After shifting, \\(a\\) becomes Trib(i) only after the increment. Dafny rejects it at the loop boundary. invariant b == Trib(i+1) Failed Violates the actual meaning of the window: \\(b\\) always equals Trib(i) , not Trib(i+1) . invariant i < n (only) Failed Not strong enough; Dafny cannot prove the correctness of the window or final result without linking \\(i\\) to the sequence. Removed a == Trib(i-1) Failed Dafny cannot prove that next == Trib(i+2) because the window reasoning breaks. Removed c == Trib(i+1) Failed Dafny cannot link next to a correct Tribonacci step. 3.2 Loop Variant Final Working Variant decreases n - i This ensures termination because the value is initially \\(\\ge 0\\) , decreases strictly with each iteration, and is bounded below by 0. Experimented Failing Variants Variant Attempt Result Why It Failed decreases i Failed \\(i\\) increases each iteration, so Dafny detects a non-decreasing variant. decreases n Failed \\(n\\) is constant and does not decrease. decreases a (or b , c ) Failed These values can increase or decrease unpredictably; the variant is not well-founded. decreases n - i - 1 Failed When \\(i = n - 1\\) , the variant becomes 0; the next iteration produces -1, which is invalid. 4. Verification Test Cases The function was tested with both valid and invalid inputs (deliberately breaking invariants or assumptions) to ensure the verifier behaves as expected. 4.1 Passing Test Cases All the following cases verified successfully: ```dafny var t0 := ComputeTrib(0); assert t0 == 0; var t1 := ComputeTrib(1); assert t1 == 1; var t2 := ComputeTrib(2); assert t2 == 1; var t3 := ComputeTrib(3); assert t3 == 2; var t4 := ComputeTrib(4); assert t4 == 4; var t5 := ComputeTrib(5); assert t5 == 7; var t10 := ComputeTrib(10); assert t10 == 149; 4.2 Fault Injection Experiments To confirm the robustness of the verification, specific faults were intentionally injected into the code. The verifier correctly identified all logical errors. Incorrect Code Implementations Fault Scenario Code Change Verification Result Removal of Base Case ( n = 0 ) Removed if n == 0 return Dafny could not prove the postcondition res == Trib(0) . Incorrect Window Initialization Initialized var a := 1 The initial invariant a == Trib(i-1) failed immediately, as 1 \u2260 T(0) . Incorrect Recurrence Relation var next := a + b (omitting c ) The logical step next == Trib(i+2) failed, violating future invariants. Returning Incorrect Variable return c Postcondition failure. At termination, c = T(n+1) , not T(n) . Incorrect Loop Bound while i <= n When i = n , the loop attempts to compute values beyond the required scope. The increment sets i to n+1 , breaking the invariant i <= n . 5. Summary The following table summarizes the components required for the formally verified implementation of ComputeTrib . Component Specifications Component Final Specification Notes Preconditions requires n >= 0 Establishes the input domain. Postconditions ensures res == Trib(n) Links implementation to the recursive mathematical definition. Loop Invariants - 1 <= i <= n - a == Trib(i-1) - b == Trib(i) - c == Trib(i+1) Essential for proving the sliding\u2010window logic. Loop Variant decreases n - i Guarantees algorithm termination. The method passed all verification checks for correctness and termination, and the verifier successfully identified all introduced faults during experimental testing.","title":"Tribonacci"},{"location":"Tribonacci_Doc/#formal-verification-report-the-computetrib-method","text":"","title":"Formal Verification Report: The ComputeTrib Method"},{"location":"Tribonacci_Doc/#1-introduction","text":"The ComputeTrib method calculates the \\(n\\) -th Tribonacci number iteratively. The Tribonacci sequence is similar to the Fibonacci sequence, but each term is the sum of the three previous terms rather than two. The sequence is defined recursively as follows: \\[ T(n) = \\begin{cases} 0 & \\text{if } n = 0 \\\\ 1 & \\text{if } n = 1 \\\\ 1 & \\text{if } n = 2 \\\\ T(n-1) + T(n-2) + T(n-3) & \\text{if } n > 2 \\end{cases} \\] The sequence begins: \\(0, 1, 1, 2, 4, 7, 13, \\dots\\) This method utilizes a \"sliding window\" approach to calculate the value in \\(O(n)\\) time complexity and \\(O(1)\\) space complexity, avoiding the exponential cost of naive recursion. This report documents all correctness conditions used in the Dafny implementation, records verification failures encountered during experimentation, and explains the rationale behind those failures.","title":"1. Introduction"},{"location":"Tribonacci_Doc/#2-formal-specification","text":"","title":"2. Formal Specification"},{"location":"Tribonacci_Doc/#21-preconditions","text":"Final Correct Preconditions (Working Version) requires n >= 0 Although defining n as a natural number ( nat ) guarantees non-negativity, the explicit precondition clarifies the domain of the function. No other preconditions are required. Experimented Failing Preconditions Attempted Condition Result Reason for Failure (none) Verified Dafny inferred bounds from nat . However, this was less clear from a specification standpoint. requires n > 0 Failed When \\(n = 0\\) , the method returns 0, but the postcondition requires res == Trib(n) where Trib(0) is valid. Restricting n > 0 made the base-case correct but unnecessary, and Dafny rejected the invariant range \\(1 \\leq i \\leq n\\) when \\(n = 0\\) .","title":"2.1 Preconditions"},{"location":"Tribonacci_Doc/#22-postconditions","text":"Final Correct Postcondition ensures res == Trib(n) This connects the implementation to the mathematical specification, ensuring functional correctness. Experimented Failing Postconditions Attempted Condition Result Reason for Failure ensures res >= 0 Verified Too weak; does not guarantee functional correctness. ensures res == Trib(n) + 1 Failed Cannot be proven true; contradicts the intended behavior. ensures res == a (or b , or c ) Failed At return time, only b holds the correct Tribonacci value. Dafny cannot prove the disjunction.","title":"2.2 Postconditions"},{"location":"Tribonacci_Doc/#3-loop-mechanics","text":"The loop invariants are critical to prove that the three variables ( \\(a, b, c\\) ) correctly represent the \"window\" of the Tribonacci sequence at any step \\(i\\) .","title":"3. Loop Mechanics"},{"location":"Tribonacci_Doc/#31-loop-invariants","text":"Final Working Invariants invariant 1 <= i <= n invariant a == Trib(i-1) invariant b == Trib(i) invariant c == Trib(i+1) Window Consistency The variables always map to specific positions in the sequence relative to \\(i\\) : \\(a\\) represents \\(T(i-1)\\) \\(b\\) represents \\(T(i)\\) (This is the value tracked for the final result) \\(c\\) represents \\(T(i+1)\\) By maintaining this window, the algorithm ensures that when the loop terminates (at \\(i == n\\) ), the variable \\(b\\) holds the value of \\(T(n)\\) . Experimented Failing Loop Invariants Invariant Attempt Result Why It Failed invariant a == Trib(i) Failed Misaligned indexing. After shifting, \\(a\\) becomes Trib(i) only after the increment. Dafny rejects it at the loop boundary. invariant b == Trib(i+1) Failed Violates the actual meaning of the window: \\(b\\) always equals Trib(i) , not Trib(i+1) . invariant i < n (only) Failed Not strong enough; Dafny cannot prove the correctness of the window or final result without linking \\(i\\) to the sequence. Removed a == Trib(i-1) Failed Dafny cannot prove that next == Trib(i+2) because the window reasoning breaks. Removed c == Trib(i+1) Failed Dafny cannot link next to a correct Tribonacci step.","title":"3.1 Loop Invariants"},{"location":"Tribonacci_Doc/#32-loop-variant","text":"Final Working Variant decreases n - i This ensures termination because the value is initially \\(\\ge 0\\) , decreases strictly with each iteration, and is bounded below by 0. Experimented Failing Variants Variant Attempt Result Why It Failed decreases i Failed \\(i\\) increases each iteration, so Dafny detects a non-decreasing variant. decreases n Failed \\(n\\) is constant and does not decrease. decreases a (or b , c ) Failed These values can increase or decrease unpredictably; the variant is not well-founded. decreases n - i - 1 Failed When \\(i = n - 1\\) , the variant becomes 0; the next iteration produces -1, which is invalid.","title":"3.2 Loop Variant"},{"location":"Tribonacci_Doc/#4-verification-test-cases","text":"The function was tested with both valid and invalid inputs (deliberately breaking invariants or assumptions) to ensure the verifier behaves as expected.","title":"4. Verification Test Cases"},{"location":"Tribonacci_Doc/#41-passing-test-cases","text":"All the following cases verified successfully: ```dafny var t0 := ComputeTrib(0); assert t0 == 0; var t1 := ComputeTrib(1); assert t1 == 1; var t2 := ComputeTrib(2); assert t2 == 1; var t3 := ComputeTrib(3); assert t3 == 2; var t4 := ComputeTrib(4); assert t4 == 4; var t5 := ComputeTrib(5); assert t5 == 7; var t10 := ComputeTrib(10); assert t10 == 149;","title":"4.1 Passing Test Cases"},{"location":"Tribonacci_Doc/#42-fault-injection-experiments","text":"To confirm the robustness of the verification, specific faults were intentionally injected into the code. The verifier correctly identified all logical errors.","title":"4.2 Fault Injection Experiments"},{"location":"Tribonacci_Doc/#incorrect-code-implementations","text":"Fault Scenario Code Change Verification Result Removal of Base Case ( n = 0 ) Removed if n == 0 return Dafny could not prove the postcondition res == Trib(0) . Incorrect Window Initialization Initialized var a := 1 The initial invariant a == Trib(i-1) failed immediately, as 1 \u2260 T(0) . Incorrect Recurrence Relation var next := a + b (omitting c ) The logical step next == Trib(i+2) failed, violating future invariants. Returning Incorrect Variable return c Postcondition failure. At termination, c = T(n+1) , not T(n) . Incorrect Loop Bound while i <= n When i = n , the loop attempts to compute values beyond the required scope. The increment sets i to n+1 , breaking the invariant i <= n .","title":"Incorrect Code Implementations"},{"location":"Tribonacci_Doc/#5-summary","text":"The following table summarizes the components required for the formally verified implementation of ComputeTrib .","title":"5. Summary"},{"location":"Tribonacci_Doc/#component-specifications","text":"Component Final Specification Notes Preconditions requires n >= 0 Establishes the input domain. Postconditions ensures res == Trib(n) Links implementation to the recursive mathematical definition. Loop Invariants - 1 <= i <= n - a == Trib(i-1) - b == Trib(i) - c == Trib(i+1) Essential for proving the sliding\u2010window logic. Loop Variant decreases n - i Guarantees algorithm termination. The method passed all verification checks for correctness and termination, and the verifier successfully identified all introduced faults during experimental testing.","title":"Component Specifications"}]}